# CLASS 05 어노테이션 기반 설정

## 5.1 어노테이션 설정 기초

   XML 파일의 과도한 설정에 대한 부담도 크며, 이로 인해 프레임워크 사용을 꺼리기도 한다. 따라서 대부분 프레임워크는 어노테이션을 이용한 설정을 지원하고 있다.

### 5.1.1 Context 네임스페이스 추가

   어노테이션 설정을 추가하려면 다음과 같이 스프링 설정 파일의 루트 엘리먼트인 <beans>에 Context 관련 네임스페이스와 스키마 문서의 위치를 등록해야 한다. 이는 p 네임스페이스를 추가했을 때처럼 [Namespaces] 탭을 선택하고 'context' 항목만 체크하면 간단하게 추가할 수 있다.


### 5.1.3 @Component

   <context:component-scan>를 설정했으면 이제 스프링 설정 파일에 클래스들을 일일이 <bean> 엘리먼트로 등록할 필요가 없다. @Component만 클래스 선언부 위에 설정하면 끝난다.
	
	

	- id나 name 속성 미지정 시 이름 규칙
	       스프링 컨테이너가 클래스 객체를 생성할 때, id나 name 속성을 지정하지 않았다면, 컨테이너가 자동으로 이름을 설정해준다. 이때 이름 규칙은 클래스 이름의 첫 글자를 소문자로 변경하기만 하면 된다. 따라서 id나 name 속성이 설정되지 않은 경우, LgTV객체를 요청하려면 lgTV라는 이름을 사용하면 된다.

## 5.2 의존성 주입 설정

### 5.2.1 의존성 주입 어노테이션

| 어노테이션 | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| @Autowired | 주로 변수 위에 설정하여 해당 타입의 객체를 찾아서 자동으로 할당한다. org.springframework.beans.factory.annotation.Autowired |
| @Qualifier | 특정 객체의 이름을 이용하여 의존성 주입할 때 사용한다. org.springframework.beans.factory.annotation.Qualifier |
| @Inject    | @Autowired와 동일한 기능을 제공한다. javax.annotation.Resource |
| @Resource  | @Autowired와 @Qualifier의 기능을 결합한 어노테이션이다. javax.inject.Inject |

### 5.2.2 @Autowired

   @Autowired은 생성자나 메소드, 멤버변수 위에 모두 사용할 수 있다. 어디에 사용하든 결과가 같아서 상관없지만, 대부분은 멤버변수 위에 선언하여 사용한다. 스프링 컨테이너는 멤버변수 위에 붙은 @Autowired를 확인하는 순간 해당 변수의 타입을 체크한다. 그리고 그 타입의 객체가 메모리에 존재하는지를 확인한 후에, 그 객체를 변수에 주입한다.

### 5.2.3 @Qualifier

   문제는 의존성 주입 대상이 되는 Speaker 타입의 객체가 두 개 이상일 때 발생한다. 만약 SonySpeaker와 AppleSpeaker 객체가 모두 메모리에 생성되어 있는 상황이라면 컨테이너는 어떤 객체를 할당할지 스스로 판단할 수 없어서 에러가 발생한다. 이런 상황에서 테스트하기 위해서 AppleSpeaker 클래스에도 @Component를 선언하자.

### 5.2.4 @Resource

   앞에서 살펴본 @Autowired는 변수의 타입을 기준으로 객체를 검색하여 의존성 주입을 처리하지만, @Resource는 객체의 이름을 이용하여 의존성 주입을 처리한다. @Resource는 name 속성을 사용할 수 있어서, 스프링 컨테이너가 해당 이름으로 생성된 객체를 검색하여 의존성 주입을 처리한다.


## 5.3 추가 어노테이션

   먼저 프레ㅇ젠테이션 레이어는 사용자와의 커뮤니케이션을 담당하고, 비즈니스 레이어는 사용자의 요청에 대한 비즈니스 로직 처리를 담당한다.

   이 구조에서 가장 핵심 요소는 Controller, ServiceImpl, DAO 클래스이다. Controller 클래스는 사용자의 요청을 제어하며, ServiceImpl 클래스는 사용자의 요청을 제어하며, ServiceImpl 클래스는 실질적인 비즈니스 로직을 처리한다. 그리고 마지막으로 DAO(Data Access Object) 클래스는 데이터베이스 연동을 담당한다.

   우리는 앞에서 @Component를 이용하여 스프링 컨테이너가 해당 클래스 객체를 생성하도록 설정할 수 있었다. 그런데 시스템을 구성하는 이 모든 클래스에 @Component를 할당하면 어떤 클래스가 어떤 역할을 수행하는지 파악하기 어렵다. 스프링 프레임워크에서는 이런 클레스들을 분류하기 위해서 @Component를 상속하여 다음과 같은 세 개의 어노테이션을 추가로 제공한다.

| 어노테이션  | 위치            | 의미                                     |
| ----------- | --------------- | ---------------------------------------- |
| @Service    | XXXServicelImpl | 비즈니스 로직을 처리하는 Service 클래스  |
| @Repository | XXXDAO          | 데이터베이스 연동을 처리하는 DAO 클래스  |
| @Controller | XXXController   | 사용자 요청을 제어하는 Controller 클래스 |

   @Controller는 해당 객체를 MVC(Model-View-Controller) 아키텍처에서 컨트롤러 객체로 인식하도록 해주며, @Repository는 DB연동 과정에서 발생하는 예외를 변환해주는 특별한 기능이 추가되어 있다. 이와 관련한 자세한 내용은 해당 과정에서 다루도록 할 것이다. 따라서 여기서는 단순히 클래스들을 분류하는 의미로만 이해하고 넘어가도록 하자.