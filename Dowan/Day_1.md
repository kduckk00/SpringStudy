# 처음 정리하는 중 !! 

# CLASS 02 프레임워크 개요
## 2.1 프레임워크 개념

  **프레임워크**란 애플리케이션을 개발할 때, 가장 중요한 것이 전체 애플리케이션의 구조를 결정하는 아키텍처인데 이 아키텍처에 해당하는 골격코드를 프레임워크가 제공한다.
		
  개발자에게 모든 것을 위임하는 것이 아니라 애플리케이션의 기본 아키텍처는 프레임워크가 제공하고, 그 뼈대에 살을 붙이는 작업만 개발자가 하는 것이다.
	
  - 프레임워크의 장점

	잘 만들어진 프레임워크를 사용하면 애플리케이션에 대한 분석, 설계, 구현 모두에서 재사용성이 증가

   **ㄱ. 빠른 구현 시간**
   
   프레임워크를 사용하면 아키텍처에 해당하는 골격 코드를 프레임워크에서 제공한다. 다라서 개발자는 비즈니스 로직만 구현하면 되므로 제한된 시간에 많은 기능을 구현할 수 있다.
	
   **ㄴ. 쉬운 관리**
   
   같은 프레임워크가 적용된 애플리케이션들은 아키텍처가 같으므로 관리하기가 쉽다. 결과적으로 유지보수에 들어가는 인력과 시간도 줄일 수 있다.
	
   **ㄷ. 개발자들의 역량 확일화**
   
   숙련된 개발자와 초급 개발자는 지식과 경험이 다르므로 두 개발자가 만든 소스의 품질은 당연히 다를 수 밖에 없다. 하지만 프레임워크를 사용하면 숙련된 개발자와 초급 개발자가 생성한 코드가 비슷해진다. 이는 초급 개발자도 프레임워크를 통해서 세련되고 효율적인 코드를 생성해낼 수 있다는 것이다. 결과적으로 관리자 입장에서 개발 인력을 더 효율적으로 구성할 수 있다.
	
   **4. 검증된 아키텍처의 재사용과 일관성 유지**
   
   프레임워크를 이용하여 애플리케이션을 개발하면, 프레임워크에서 제공하는 아키텍처를 이용하므로 아키텍처에 관한 별다른 고민이나 검증 없이 소프트웨어를 개발할 수 있다. 또한 이렇게 개발한 시스템은 시간이 지나도 유지보수 과정에서 아키텍처가 왜곡되거나 변형되지 않는다.
	
  - 자바 기반의 프레임워크
  
	|처리 영역|프레임워크|설명|
	|---|---|---|
	|Presentaion|Struts|Struts 프레임워크는 UI Layer에 중점을 두고 개발된 MVC(Model View Controlller) 프레임워크이다.|
	|Presentaion|Spring (MVC)|Struts와 동일하게 MVC 아키텍처를 제공하는 UI Layer프레임워크이다. 하지만 Struts처럼 독립된 프레임워크는 아니고 Spring 프레임워크에 포함되어 있다.|
	|Business|Spring (IoC, AOP)|Spring은 컨테이너 성격을 가지는 프레임워크이다. Spring의 IoC와 AOP 모듈을 이요하여 Spring 컴테이너에서 동작하는 엔터프라이즈 비즈니스 컴포넌트를 개발할 수 있다.|
	|Persistence|Hibernate or JPA|Hibernate는 완벽한 ORM(Object Relation Mapping) 프레임워크이다. ORM 프레임워크는 SQL 명령어를 프레임워크가 자체적으로 생성하여 DB 연동을 처리한다. JPA는 Hibernate를 비롯한 모든 ORM의 공통 인터페이스를 제공하는 자바 표준 API이다.|
	|Persistence|Ibatis or Mybatis|Ibatis 프레임워크는 개발자가 작성한 SQL 명령어와 자바 객체(VO 혹은 DTO)를 매핑해주는 기능을 제공하며, 기존에 사용하던 SQL 명령어를 재사용하여 개발하는 차세대 프로젝트에 유용하게 적용할 수 있다. Mybatis는 Ibatis에서 파생된 프레임워크로서 기본 개념와 문법은 거의 같다.|
    
## 2.2 스프링 프레임워크

  스프링프레임워크는 로드 존슨(Rod Johnson)이 2004년에 만든 오픈소스 프레임워크다. 스프링 프레임워크가 등장하기 이전에 자바 기반의 엔터프라이즈 애플리케이션은 대부분 EJB(Enterprise Java Beans)로 개발되었다. 그러나 EJB 기술은 EJB 컨테이너가 제공하는 많은 기능과 나름의 장점에도 불구하고 다음과 같은 여러가지 문제점 때문에 개발자들로부터 외면 받을수 밖에 없었다.
		
    POJO(Palin Old JAva Object)란?
    
	   POJO란 말 그대로 평범한 옛날 자바 객체를 의미한다. POJO를 좀 더 쉽게 이해하기 위해서 반대로 POJO가 아닌 클래스가 무엇인지 이해하면 된다. 대표적인 Not POJO 클래스가 Servlet 클래스이다. Servlet 클래스는 우리 마음대로 만들 수 없으며, 반드시 Servler에서 요구하는 규칙에 맞게 클래스를 만들어야 실행할 수 있다. 다음은 Servlet 클래스 작성 규칙이다.
	  - javax.servlet, javax.servlet.http 패키지를 import해야 한다.
	  - public 클래스로 선언되어야 한다.
	  - Servlet, GenericServlet, HttpServlet 중 하나를 상속해야한다.
	  - 기본 생성자(Default Constructor)가 있어야한다.
	  - 생성주기에 해당하는 메소드를 재정의(Overriding)한다.
			
  - 스프링 프레임워크의 특징
	IoC와 AOP를 지원하는 경량의 컨테이너 프레임워크
			
   **ㄱ.경량**
  
   스프링은 여러 개의 모듈로 구성되어 있으며, 각 모듈은 하나 이상의 JAR파일로 구성되어 있다. 그리고 이 몇 개의 JAR파일만 있으면 개발과 실행이 모두 가능하다. 따라서 스프링을 이용해서 만든 애플리케이션의 배포 역시 매우 빠르고 쉽다.
   스프링 프레임워크가 POJO형태의 객체를 관리하기 댸문이다. POJO는 클래스를 구현하는 데 특별한 규칙이 없는 단순하고 가벼운 객체이므로 POJO를 관리하는 것은 기존 EJB객체를 관리하는 것보다 훨씬 가볍고 빠를 수 밖에 없다.
			
  **ㄴ. 제어의 역행(Inversion of Control)**
  
   비즈니스 컴포넌트를 개발할 때, 항상 신경 쓰는 것이 바로 낮은 결합도와 높은 응집도이다. 스프링은 제어의 역행을 통해 애플리케이션을 구성하는 객체 간의 느슨한 결합, 즉 낮은 결합도를 유지한다.	
   IoC가 적용되지 않은 상황과 IoC가 적용된 상황을 비교하면 IoC가 적용되기 전에는 애플리케이션 수행에 필요한 객체의 생성이나 객체와 객체 사이의 의존관계를 개발자가 직접 자바 코드로 처리했었다. 이런 상황에서는 의존관계에 있는 객체를 변경할 때, 반드시 자바코드를 수정해야한다.
   IoC가 적용되면 객체 생성을 자바코드로 직접 처리하는것이 아니라 컨테이너가 대신 처리한다. 그리고 객체와 객체 사이의 의존관계 역시 컨테이너가 처리한다. 결과적으로 소스에 의존관계가 명시되지 않으므로 결합도가 떨어져서 유지보수가 편리해 진다.
			
  **ㄷ. 관점지향 프로그래밍(Aspect Oriented Programming, AOP)**
  
   관점지향 프로그래밍은 비지니스 메소드를 개발할 때, 핵심 비지니스 로직과 각 비지니스 메소드마다 반복해서 등장하는 공통 로직을 분리함으로써 응집도가 높에 개발할 수 있도록 원한다.
   공통으로 사용하는 기능들을 외부의 독립된 클래스로 분리하고, 해당 기능을 프로그램 코드에 직접 명시하지 않고 선언적으로 처리하여 적용하는 것이 관점지향 프로그래밍의 기본 개념이다. 이렇게 되면 공통기능을 분리하여 관리할수 있으므로 응집도가 높은 비즈니스 컴포넌트를 만들 수 있을 뿐만 아니라 유지보수를 혁신적으로 향상 시킬수 있다.

  **ㄹ. 컨테이너(Container)**
  
   컨테이너는 특징 객체의 생성과 관리를 담당하여 객체 운용에 필요한 다양한 기능을 제공한다. 컨테이너는 일반적으로 서버 안에 포함되어 배포 및 구동된다. 대표적인 컨테이너로 Servlet객체를 생성하고 관리하는 'Servlet 컨테이너'와 EJB 객체를 생성하고 관리하는 'EJB 컨테이너'가 있다. 그리고 Servlet컨테이너는 우리가 사용하는 톰캣 서버에도 포함되어 있다. 애플리케이션 운용에 필요한 객체를 생성하고 객체 간의 의존관계를 관리한다는 점에서 스프링도 일종의 컨테이너라고 할 수 있다.
	
## 2.3 IoC(Inversion of Control)컨테이너
~~정리중~~ 

* * *

# CLASS 03 스프링 컨테이너 및 설정 파일

   스프링 프레임워크도 다른 컨테이너와 마찬가지로 자신이 관리할 클래스들이 등록된 XML 설정파일이 필요하다. 스프링 컨테이너가 사용할 XML 파일은 앞에서 설치한 STS를 이용하면 간단하게 만들수 있다.

## 3.1 스프링 IoC 시작하기

   - 스프링 컨테이너의 종류
     스프링에서는 BeanFactory와 이를 상속한 ApplicationContext 두 가지 유형의 컨테이너를 제공한다. 먼저 BeanFactory는 스프링 설정 파일에 등록된 <bean> 객체를 생성하고 관리하는 가장 기본적인 컨테이너 기능만 제공한다. 그리고 컨테이너가 구동될 때 <bean> 객체를 생성하는 것이 아니라, 클라이언트의 요청(Lookup)에 의해서만 <bean> 객체가 생성되는 지연 로딩방식을 사용한다. 일반적인 스프링 프로젝트에서 BeanFactory를 사용할일은 전혀 없다.
	
   |구현 클래스|기능|
   |---|---|
   |GenericXmlApplicationContext|파일 시스템이나 클래스 경로에 있는 XML 설정 파일을 로딩하여 구동하는 컨테이너이다.|
   |XmlWebApplicationContext|웹 기반의 스프링 애플리케이션을 개발할 때 사용하는 컨테이너이다.|
   
   GenericXmlApplicationContext은 실습에서 사용한 컨테이너로서 TVUser 클라이언트에서 직접 객체를 생성하여 구동한 컨테이너다. 하지만 XmlWebApplication은 웹 애플리케이션 개발에 사용되며, 우리가 직접 생성하지 않는 컨테이너다. XmlWebApplication이 어떻게 구동되고 사용되는지는 Spring MVC를 학습할 때 확인할 수 있으므로 당분간은 GenericXmlApplicationContext만을 기억하기 바란다.
   
   
## 3.2 스프링 XML 설정
   ~~정리중~~ 
   
* * *

# CLASS 04 의존성 주입
## 4.1 스프링의 의존성 관리 방법

   스프링은 IoC를 다음 두가지 형태로 지원한다. 
   - Dependency Lookup 컨테이너가 애플리케이션 운용에 필요한 객체를 생성하고 클라이언트는 컨테이너가 생성한 객체를 검색하여 사용하는 방식(실제 개발에서 사용하지 않음)
   - Dependency Injection은 의존성 설정을 바꾸고 싶을 떄 프로그램 코드를 수정하지 않고 스프링 설정 파일 수정만으로 변경사항을 적용할 수 있어서 유지보수가 향상된다. (실제 개발에서 사용)

   의존성관계란 하나의 객체에서 다른 객체의 변수나 메소드를 이용해야한다면 이용하려는 객체에 대한 객체 생성과 생성된 객체의 레퍼런스정보가 필요하다.
   
# p.69 이해 X ..		
## 4.2 생성자 인젝션 이용하기 

   스프링 컨테이너는 XML 설정 파일에 등록된 클래스를 찾아서 객체 생성 할 떄 기본적으로 매개변수가 없는 기본 생성자를 호출한다. 하지만 컨테이너가 기본 생성자 말고 매개변수를 가지는 다른 생성자를 호출하도록 설정할 수 있는데, 이기능을 이용하여 생성자 인젝션을 처리한다. 생성자 인젝션을 사용하면 생성자의 매개변수로 의존관계에 있는 객체의 주소 정보를 전달할 수 있다.
			
	이클립스 생성자 추가 단축키
	Alt + Shift + S키를 누르고 Generate Constructor using Fields 를 선택
	
# p.80 또한 이해 X ..
## 4.3 Setter 인젝션 이용하기 

	이클립스 Setter 메소드 자동생성 단축키
	Alt + Shift + S키를 누르고 Generate Getters and Setters... 를 선택

## 4.4 컬렉션(Collection) 객체 설정


* * *

# CLASS 05 어노테이션 기반 설정

## 5.1 어노테이션 설정 기초

   XML 파일의 과도한 설정에 대한 부담도 크며, 이로 인해 프레임워크 사용을 꺼리기도 한다. 따라서 대부분 프레임워크는 어노테이션을 이용한 설정을 지원하고 있다.

### 5.1.1 Context 네임스페이스 추가

   어노테이션 설정을 추가하려면 다음과 같이 스프링 설정 파일의 루트 엘리먼트인 <beans>에 Context 관련 네임스페이스와 스키마 문서의 위치를 등록해야 한다. 이는 p 네임스페이스를 추가했을 때처럼 [Namespaces] 탭을 선택하고 'context' 항목만 체크하면 간단하게 추가할 수 있다.


### 5.1.3 @Component

   <context:component-scan>를 설정했으면 이제 스프링 설정 파일에 클래스들을 일일이 <bean> 엘리먼트로 등록할 필요가 없다. @Component만 클래스 선언부 위에 설정하면 끝난다.
	
	
	- id나 name 속성 미지정 시 이름 규칙
           스프링 컨테이너가 클래스 객체를 생성할 때, id나 name 속성을 지정하지 않았다면, 컨테이너가 자동으로 이름을 설정해준다. 이때 이름 규칙은 클래스 이름의 첫 글자를 소문자로 변경하기만 하면 된다. 따라서 id나 name 속성이 설정되지 않은 경우, LgTV객체를 요청하려면 lgTV라는 이름을 사용하면 된다.
	
## 5.2 의존성 주입 설정

### 5.2.1 의존성 주입 어노테이션

|어노테이션|설명|
|---|---|
|@Autowired|주로 변수 위에 설정하여 해당 타입의 객체를 찾아서 자동으로 할당한다. org.springframework.beans.factory.annotation.Autowired|
|@Qualifier|특정 객체의 이름을 이용하여 의존성 주입할 때 사용한다. org.springframework.beans.factory.annotation.Qualifier|
|@Inject|@Autowired와 동일한 기능을 제공한다. javax.annotation.Resource|
|@Resource|@Autowired와 @Qualifier의 기능을 결합한 어노테이션이다. javax.inject.Inject|
	
### 5.2.2 @Autowired
   @Autowired은 생성자나 메소드, 멤버변수 위에 모두 사용할 수 있다. 어디에 사용하든 결과가 같아서 상관없지만, 대부분은 멤버변수 위에 선언하여 사용한다. 스프링 컨테이너는 멤버변수 위에 붙은 @Autowired를 확인하는 순간 해당 변수의 타입을 체크한다. 그리고 그 타입의 객체가 메모리에 존재하는지를 확인한 후에, 그 객체를 변수에 주입한다.
   
### 5.2.3 @Qualifier
   문제는 의존성 주입 대상이 되는 Speaker 타입의 객체가 두 개 이상일 때 발생한다. 만약 SonySpeaker와 AppleSpeaker 객체가 모두 메모리에 생성되어 있는 상황이라면 컨테이너는 어떤 객체를 할당할지 스스로 판단할 수 없어서 에러가 발생한다. 이런 상황에서 테스트하기 위해서 AppleSpeaker 클래스에도 @Component를 선언하자.

### 5.2.4 @Resource
   앞에서 살펴본 @Autowired는 변수의 타입을 기준으로 객체를 검색하여 의존성 주입을 처리하지만, @Resource는 객체의 이름을 이용하여 의존성 주입을 처리한다. @Resource는 name 속성을 사용할 수 있어서, 스프링 컨테이너가 해당 이름으로 생성된 객체를 검색하여 의존성 주입을 처리한다.


## 5.3 추가 어노테이션

   먼저 프레ㅇ젠테이션 레이어는 사용자와의 커뮤니케이션을 담당하고, 비즈니스 레이어는 사용자의 요청에 대한 비즈니스 로직 처리를 담당한다.
   
   이 구조에서 가장 핵심 요소는 Controller, ServiceImpl, DAO 클래스이다. Controller 클래스는 사용자의 요청을 제어하며, ServiceImpl 클래스는 사용자의 요청을 제어하며, ServiceImpl 클래스는 실질적인 비즈니스 로직을 처리한다. 그리고 마지막으로 DAO(Data Access Object) 클래스는 데이터베이스 연동을 담당한다.
   
   우리는 앞에서 @Component를 이용하여 스프링 컨테이너가 해당 클래스 객체를 생성하도록 설정할 수 있었다. 그런데 시스템을 구성하는 이 모든 클래스에 @Component를 할당하면 어떤 클래스가 어떤 역할을 수행하는지 파악하기 어렵다. 스프링 프레임워크에서는 이런 클레스들을 분류하기 위해서 @Component를 상속하여 다음과 같은 세 개의 어노테이션을 추가로 제공한다.
   
   |어노테이션|위치|의미|
   |---|---|---|
   |@Service|XXXServicelImpl|비즈니스 로직을 처리하는 Service 클래스|
   |@Repository|XXXDAO|데이터베이스 연동을 처리하는 DAO 클래스|
   |@Controller|XXXController|사용자 요청을 제어하는 Controller 클래스|
   
   @Controller는 해당 객체를 MVC(Model-View-Controller) 아키텍처에서 컨트롤러 객체로 인식하도록 해주며, @Repository는 DB연동 과정에서 발생하는 예외를 변환해주는 특별한 기능이 추가되어 있다. 이와 관련한 자세한 내용은 해당 과정에서 다루도록 할 것이다. 따라서 여기서는 단순히 클래스들을 분류하는 의미로만 이해하고 넘어가도록 하자.
	
