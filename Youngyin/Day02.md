# 1. 스프링 AOP

스프링의 **IoC**가 결합도와 관련된 기능이라면 **AOP**는 응집도와 관련된 기능이라고 할 수 있다.

AOP에서는 메소드마다 공통으로 등장하는 로깅이나 예외, 트랜잭션 처리 같은 코드들을 **횡단 관심**이라고 한다. 이에 반해 사용자의 요청에 따라 실제로 수행되는 핵심비즈니스 로직을 **핵심 관심**이라고 한다.

기존의 OOP(Object Oriented Programming) 언어에서는 핵심 관심과 횡단 관심을 완벽하게 독립적인 모듈로 분리해내기가 어렵다.

스프링의 AOP는 클라이언트가 **핵심 관심에 해당하는 비즈니스 메소드를 호출**할 때, **횡단 관심에 속하는 메소드를 적절하게 실행**해준다. 이때 핵심 관심 메소드와 횡단 관심 메소드 사이에서 소스상의 결합은 발생하지 않으며, 이것이 우리가 AOP를 사용하는 주된 목적이다.



# 2. AOP 용어 및 기본 설정

## 2.1 AOP 용어 정리

### 2.1.1 조인포인트

* 클라이언트가 호출하는 모든 비즈니스 메소드

* 조인 포인트 중에서 포인트 컷이 선택되기 때문에 조인포인트를 다음에 설명할 **포인트컷 대상** 또는 **포인트 컷 후보**라고도 한다.

### 2.1.2 포인트컷

* 필터링된 조인포인트
* 수많은 비즈니스 메소드 중에서 특정 메소드에만 횡단 관심에 해당하는 공통 기능을 수행시키기 위해 포인트컷이 필요하다.
* 포인트컷은 \<aop:pointcut> 엘리먼트로 선언
* id 속성으로 포인트컷을 식별하기 위한 유일한 문자열을 선언
* expression 속성을 어떻게 설정하느냐에 따라 필터링되는 메소드가 달라진다.

### 2.1.3 어드바이스

* 횡단 관심에 해당하는 공통 기능의 코드를 의미하며, 독립된 클래스의 메소드로 작성된다.
* 어드바이스의 동작시점을 **before, after, after-returning, after-throwing, around** 등 다섯가지로 지정할 수 있다.

### 2.1.4 위빙

* 위빙은 포인트컷으로 지정한 핵심 관심 메소드가 호출될 때, 어드바이스에 해당하는 관심 메소드가 삽입되는 과정을 의미한다.
* 위빙을 통해 비즈니스 메소드를 수정하지 않고도 횡단 관심에 해당하는 기능을 추가하거나 변경할 수 있다.
* 위빙을 처리하는 방식은 **컴파일 위빙, 로딩타임 위빙, 런타임 위빙**이 있으며 스프링에서는 런타임 위빙 방식만 지원한다.

### 2.1.5 애스팩트 또는 어드바이저

* 포인트컷과 어드바이스의 결합
* 어떤 포인트컷 메소드에 대해서 어떤 어드바이스 메소드를 실행할지 결정한다.
* 에스펙트를 설정할 때는 \<aop:aspect> 엘리먼트를 사용하며 트랜잭션 상황의 경우 \<aop:advisor>을 사용한다.

### 2.1.6 AOP 용어 종합

?<그림 2-6 용어정리>

## 2.2 AOP 앨리먼트

?<그림 2-7 AOP 엘리먼트들의 포함관계>

### 2.2.1 \<aop:config> 

* AOP설정에서 \<aop:config>는 루트 엘리먼트이다.
* 스프링 설정 파일 내에 \<aop:config> 엘리먼트는 여러 번 사용 할 수 있다.
* \<aop:config>엘리먼트 하위에는 \<aop:pointcut>, \<aop:aspect> 엘리먼트가 위치할 수 있다.

### 2.2.2 \<aop:pointcut> 

* \<aop:pointcut> 엘리먼트는 포인트컷을 지정하기 위해 사용
* \<aop:config> 또는 \<aop:aspect> 의 자식 엘리먼트로 사용할 수 있다.
* \<aop:aspect> 하위에 설정된 포인트컷은 해당 \<aop:aspect>에서만 사용할 수 있다.
* \<aop:pointcut>은 여러개 정의할 수 있으며 유일한 아이디를 할당하여 애스펙트를 설정할 때 포인트컷을 참조하는 용도로 사용한다.

### 2.2.3 \<aop:aspect>

* 핵심 관심에 해당하는 포인트컷 메소드와 횡단 관심에 해당하는 어드바이스 메소드를 결합하기 위해 사용한다.

### 2.2.4 \<aop:advisor>

* \<aop:advisor> 엘리먼트는 포인트컷과 어드바이스를 결합하는 점에서 애스팩트와 같은 기능을 한다.
* 트랜잭션 설정 같은 특수한 경우 애스팩트가 아닌 어드바이저를 사용해야 한다.
  * 어드바이스 객체의 아이디를 모르거나 메소드 이름을 확인할 수 없을 때는 애스팩트를 설정할 수 없다.  

## 2.3 포인트컷 표현식

포인트컷 표현식은 execution 명시자 안에 포인트컷 표현식을 기술한다.

?<그림 2-10 포인트컷 표현식의 구조와 의미>

### :one: 리턴타입 지정

| 설명  | 표현식                             |
| ----- | ---------------------------------- |
| *     | 모든 리턴타입 허용                 |
| void  | 리턴타입이 void인 메소드 선택      |
| !void | 리턴타입이 void가 아닌 메소드 선택 |

### :two: 패키지 지정

| 설명                 | 표현식                                                       |
| -------------------- | ------------------------------------------------------------ |
| com.springbook.biz   | 정확하게 com.springbook.biz 패키지만 선택                    |
| com.springbook.biz.. | com.springbook.biz 패키지로 시작하는 모든 패키지 선택        |
| com.springbook..impl | com.springbook 패키지로 시작하면서 마지막 이름이 impl로 끝나는 패키지 선택 |

### :three: 클래스 지정

| 설명             | 표현식                                                       |
| ---------------- | ------------------------------------------------------------ |
| BoardServicelmpl | 정확하게 BoardServicelmpl 클래스만 선택                      |
| *lmpl            | 클래스 이름이 lmpl로 끝나는 클래스만 선택                    |
| BoardService+    | **클래스 이름 뒤에 +** (해당 클래스로부터 파생된 모든 자식 클래스), **인터페이스 이름 뒤에 +** (인터페이스를 구현한 모든 클래스) |

### :four: 메소드 지정

| 설명     | 표현식                                          |
| -------- | ----------------------------------------------- |
| *(..)    | 가장 기본 설정으로 모든 메소드 설정             |
| get*(..) | 메소드 이름이 get으로 시작하는 모든 메소드 선택 |

### :five: 매개변수 지정

| 설명                          | 표현식                                                       |
| ----------------------------- | ------------------------------------------------------------ |
| (...)                         | 가장 기본 설정, 매개변수의 개수와 타입에 제약 없음           |
| (*)                           | 반드시 1개의 매개변수를 가지는 메소드만 선택                 |
| (com.springbook.user.UserVO)  | 매개변수로 UserVO를 가지는 메소드만 선택, 이 때 클래스의 패키지 정보가 반드시 포함되어야 함 |
| (!com.springbook.user.UserVO) | 매개변수로 UserVO를 가지지 않는 메소드만 선택                |
| (Inter, ...)                  | 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택 |
| (inter, *)                    | 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택 |



# 3. 어드바이스 동작 시점

| 동작 시점        | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| Before           | 비즈니스 메소드 실행 전 동작                                 |
| After Returuning | 비즈니스 메소드가 성공적으로 리턴되면 동작                   |
| After Throwing   | 비즈니스 메소드 실행중 예외가 발생하면 동작(try~catch 블록에서 catch 블록에 해당) |
| After            | 비즈니스 메소드가 실행된 후, 무조건 실행(try~catch~finally 블록에서 finally 블록에 해당) |
| Aournd           | 비즈니스 실해 전후에 처리할 로직을 삽입할 수 있음            |



# 4. JoinPoint와 바인드 변수

횡단 관심에 해당하는 어드바이스 메소드를 의미있게 구현하려면 클라이언트가 호출한 비즈니스 메소드의 정보가 필요하다. 스프링에서는 다양한 정보들을 이용할 수 있도록 JointPoint 인터페이스를 제공한다.

## 4.1 JointPoint 메소드

* JointPoint에서 제공하는 메소드

| 메소드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Signature getSignature() | 클라이언트가 호출한 메소드의 시그니처(리턴타입, 이름, 매개변수) 정보가 저장된 Signature 객체 리턴 |
| Object getTarget()       | 클라이언트가 호출한 비즈니스 메소드를 포함하는 비즈니스 객체 리턴 |
| Object[] getArgs()       | 클라이언트가 메소드를 호출할 때 넘겨준 인자 목록을 Object 배열로 리턴 |

* Signature 객체가 제공하는 메소드

| 메소드                 | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| String getName()       | 클라이언트가 호출한 메소드 이름 리턴                         |
| String toLongString()  | 클라이언트가 호출한 메소드의 리턴타입, 이름, 매개변수를 패키지 경로까지 포함하여 리턴 |
| String toShortString() | 클라이언트가 호출한 메소드 시그니처를 축약한 문자열로 리턴   |

## 4.2 Before 어드바이스

비즈니스 메소드가 실행되기 전에 동작할 로직을 구현한다.

## 4.3 Ater Returning 어드바이스

비즈니스 메소드가 수행되고 나서, 결과 데이터를 리턴할 때 동작하는 어드바이스이다.

## 4.4 After Throwing 어드바이스

비즈니스 메소드가 수행되다가 예외가 발생할 때 동작하는 어드바이스이다.

## 4.5 Around 어드바이스

* Around 어드바이스는 다른 어드바이스와는 다르게 ProceedingJointPoint 객체를 매개변수로 받아야 한다.
* ProceedingJointPoint 객체는 비즈니스 메소드를 호출하는 proceed() 메소드를 가지고 있으며 JointPoint를 상속했다.



# 5. 어노테이션 기반 AOP

## 5.1 어노테이션 기반 AOP설정

### 5.1.1 어노테이션 사용을 위한 스프링 설정

* AOP를 어노테이션으로 설정하여면 가장 먼저 스프링 설정 파일에 \<api:aspectj-autoproxy> 엘리먼트를 선언해야 한다.

* AOP 관련 어노테이션을 스프링 컨테이너가 처리하게 하려면 반드시 어드바이스 객체가 생성되어 있어야 한다.

| Annotaion 설정 | XML 설정                                                    |
| -------------- | ----------------------------------------------------------- |
| @Service       | \<bean id = "log" class = "polymorphism.LogAdvice">\</bean> |

### 5.1.2 포인트컷 설정

* XML에서 포인트 컷을 사용할 때는 \<api:pointcut>을 사용했다.
* 어노테이션 설정으로 포인트컷을 선언할 때는 @Pointcut을 사용하며, 하나의 어드바이스 클래스 안에 여러개의 포인트 컷을 선언 할 수 있다.
* 참조 메소드는 구현 로직이 없는 메소드로 포인트 컷을 식별하는 이름으로만 사용된다.

### 5.1.3 어드바이스 설정

* 어드바이스 어노테이션 뒤에 괄호를 추가하고 포인트컷 참조 메소드를 지정한다.

| 어노테이션        | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| @Before           | 비즈니스 메소드 실행 전 동작                                 |
| @After Returuning | 비즈니스 메소드가 성공적으로 리턴되면 동작                   |
| @After Throwing   | 비즈니스 메소드 실행중 예외가 발생하면 동작(try~catch 블록에서 catch 블록에 해당) |
| @After            | 비즈니스 메소드가 실행된 후, 무조건 실행(try~catch~finally 블록에서 finally 블록에 해당) |
| @Aournd           | 비즈니스 실해 전후에 처리할 로직을 삽입할 수 있음            |

### 5.1.4 애스펙트 설정

* 포인트컷과 어드바이스의 결합
* @Aspect가 설정된 에스펙트 객체에는 반드시 포인트컷과 어드바이스를 결합하는 설정이 있어야 한다.

## 5.2 어드바이스 동작 시점

| 어드바이스       | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| Before           | 비즈니스 메소드 실행 전 공통으로 처리할 작업                 |
| After Returuning | 비즈니스 메소드가 리턴한 결과 데이터를 가른 용도로 처리할 때 사용 |
| After Throwing   | 비즈니스 메소드 실행중 예외가 발생했을 때, 공통적인 예외 처리 로직을 제공할 목적으로 사용 |
| After            | 예외 발생 여부에 관계 없이 무조건 수행되는 어드바이스        |
| Aournd           | 하나의 어드바이스로 사전, 사후 처리를 모두 해결하고자 할 때 사용 |

### 5.2.6 외부 PointCut 참조하기

* XML 설정으로 포인트컷을 관리했을 때는 :point_up: 포인트컷을 여러개 등록 할 수 있었으며, :v: pointcut-ref 속성으로 특정 포인트컷을 참조해 재사용할 수 있었다.
* 어노테이션 설정으로 변경하고 나서는 비슷하거나 같은 포인트컷이 반복 선언되는 문제가 발생한다.
* 포인트컷을 외부에 독립된 클래스에 따로 설정하도록 하여 문제를 해결할 수 있다.

# 6. 스프링 JDBC

* JDBC
  * 가장 오랫동안 자바 개발자들이 사용한 DB 연동기술
  * 데이터베이스에 비종속적인 DB로직 구현 가능
  * :mag: 개발자가 작성해야 할 코드가 너무 많다.
  * :mag: ​다른 메소드를 구현할 때마다 반복해서 작성해야 한다.

* 스프링은 JDBC 기반의 DB 연동 프로그램을 쉽게 개발할 수 있도록 JdbcTemplate 클래스를 지원한다.
* JdbcTemplate 클래스
  * 템플릿 메소드 패턴이 적용된 클래스
  * JDBC의 반복적인 코드를 제거하기 위해 제공
  * 내부적으로 JDBC API를 이용하여 실제 DB 연동 작업을 처리

### 6.4 JdbcTemplate 메소드

| 메소드           | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| update()         | INSERT, UPDATE, DELETE 구문을 처리                           |
| queryForInt()    | SELECT 구문으로 검색된 정수값을 리턴                         |
| queryForObject() | SELECT 구문의 실행 결과를 특정 자바 객체로 매핑하여 리턴 받을 때 사용 |
| query()          | SELECT 구문의 실행 결과가 목록일 때 사용, 객체 여러개가 List 컬렉션에 저장되어 리턴된다. |

### 6.5 JdbcTemplate 객체를 얻는 방법

* JdbcDaoSupport 클래스를 상속하는 방법
* JdbcTemplate 클래스 \<bean> 등록, 의존성 주입



# 7. 트랜잭션 처리

* EJB
  * 트랜젝션 관리를 EJB 컨테이너가 자동으로 처리
* 스프링
  * 선언적 트랜젝션 처리: 트랜젝션 관리를 EJB 컨테이너가 자동으로 처리
  * XML 기반의 AOP 설정만 사용할 수 있다.
    * \<aop:aspect> 엘리먼트를 사용하지 못하고 \<aop:advisor> 엘리먼트를 사용해야 한다.
* 트랜젝션 관리자
  * platformTransactionManager 인터페이스를 구현한 클래스
  * commit(), rollback() 메소드를 가지고 있다.
* 트랜젝션 어드바이스
  * \<tx:advice> 엘리먼트 이용
  * 트랜젝션 관리 기능의 어드바이스는 직접 구현하지 않으며 스프링 컨테이너가 \<tx:advice> 설정을 참조하여 자동으로 생성
  * \<tx:method> 엘리먼트를 사용하여 트랜잭션을 적용할 메소드를 지정할 수 있다.

| 속성            | 설명                               |
| --------------- | ---------------------------------- |
| name            | 트랜잭션이 적용될 메소드 이름 지정 |
| read-only       | 읽기 전용 여부 지정(기본값 Falsae) |
| no-rollback-for | 트램잭션을 롤백하지 않을 예외 지정 |
| rollback-for    | 트램잭션을 롤백할 예외 지정        |

* 트랜잭션 관리릐 동작 순서

?<그림7-3 트랜잭션 관리의 동작 순서>